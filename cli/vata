#!/usr/bin/env python3
import argparse
import os
import subprocess
import sys
import tempfile


VATA_CODE_NAME = 'vata-code'
GDB_COMMAND = os.path.expandvars('$GDB')


###########################################
def find_vata_path():
    '''find_vata_path() -> string

Finds the path to the vata-code executable.
'''
    dirname, filename = os.path.split(sys.argv[0])
    vata_code_dirname = os.path.join(dirname, '..' , 'build', 'cli')
    vata_path = os.path.join(vata_code_dirname, VATA_CODE_NAME)
    os.path.isfile(vata_path)
    return vata_path


###########################################
def get_vata_version():
    '''get_vata_version() -> string

Retrieves the version of libVATA.
'''
    result = ''
    result += call_vata_code(['-v'])
    return result


###########################################
def call_vata_code(params=None, input=None, debug=False):
    '''call_vata_code([params], input=None) -> str

Calls vata-code with the given 'params' and 'input'.  Input is fed into
vata-code on STDIN.  The string from STDOUT is returned.
'''
    command = [VATA_PATH]
    if params:
        command += params

    if not debug:
        compl_proc = subprocess.run(
            command,
            input=input,
            stdout=subprocess.PIPE,
            universal_newlines=True,
            check=True)
        return compl_proc.stdout
    else:
        assert debug
        tmp = tempfile.NamedTemporaryFile(mode='w+t',delete=False)
        tmp.write(input)
        tmp.close()
        command = command + [tmp.name]
        command = [GDB_COMMAND, '--args'] + command
        os.execvp(GDB_COMMAND, [GDB_COMMAND] + command)
        # exec removes the python script


###########################################
def create_code_str(cmds):
    '''create_code_str(cmds) -> string

Creates a @CODE string in the .vtf format using 'cmds' as the commands to execute.
'''
    header = \
        '# Generated by libVATA2 CLI interface\n' \
        '\n' \
        '@CODE\n'
    return header + cmds


###########################################
def errprint(str):
    '''errprint(str) -> ()

Prints onto stderr.
'''
    print('error: ' + str, file=sys.stderr)


###########################################
def check_num_params(expected, provided):
    '''check_num_params(expected, provided) -> ()

Raises an exception if 'expected' != 'provided'.
'''
    if expected != provided:
        raise Exception('Number of provided parameters (' + str(provided) + \
            ') does not match the number of expected (' + str(expected) + ')')

###########################################
def run_main(args):
    '''run_main(args) -> ()

Runs the main program according to the arguments obtained from the parser.
'''
    # we create lambdas - cannot construct the strings yet because we don't
    # know how many arguments we have
    unary_load = lambda : '(load_aut "{0}")'.format(args.inputs[0])
    binary_load = lambda : '(load_aut "{0}") (load_aut "{1}")'.format(args.inputs[0], args.inputs[1])

    # according to the operation
    if args.oper == 'load':
        check_num_params(1, len(args.inputs))
        cmds = unary_load
    elif args.oper == 'union':
        check_num_params(2, len(args.inputs))
        cmds = '(union {})'.format(binary_load())
    elif args.oper == 'isect':
        check_num_params(2, len(args.inputs))
        cmds = '(isect {})'.format(binary_load())
    elif args.oper == 'empty':
        check_num_params(1, len(args.inputs))
        cmds = '(is_empty {})'.format(unary_load())
    elif args.oper == 'univ':
        check_num_params(1, len(args.inputs))
        cmds = '(is_univ {})'.format(unary_load())
    elif args.oper == 'incl':
        check_num_params(2, len(args.inputs))
        cmds = '(is_incl {})'.format(binary_load())
    elif args.oper == 'eq':
        check_num_params(2, len(args.inputs))
        cmds = '(is_eq {})'.format(binary_load())
    else:
        raise Exception('unknown operation \'' + args.oper + '\'')

    print('blah')

    assert cmds
    cmds = 'res = ' + cmds + '\n(print res)\n';
    code_str = create_code_str(cmds)
    if not args.file:
        res = call_vata_code(input=code_str, debug=args.debug)
        print(res)
    else:
        print(code_str)


###########################################
if __name__ == '__main__':
    try:
        VATA_PATH = find_vata_path()
        CLI_OPERATIONS = ['load', 'isect', 'union', 'empty', 'univ', 'incl', 'eq']
        vata_version_str = get_vata_version()

        parser = argparse.ArgumentParser(description='User interface to libVATA2')
        parser.add_argument('oper', metavar='op', choices=CLI_OPERATIONS,
                            help='operation to be performed (one of {' +
                            ', '.join(CLI_OPERATIONS) + '})')

        parser.add_argument('inputs', metavar='AUT', nargs='*',
                            help='files with input automata in the .vtf format')

        parser.add_argument('-v', '--version', action='version', version=vata_version_str)
        parser.add_argument('-f', '--file', action='store_true',
            help='only output a @CODE file in the ' + '.vtf format, do not run ' +
            VATA_CODE_NAME)
        parser.add_argument('-d', '--debug', action='store_true',
            help='run ' + VATA_CODE_NAME + ' in $GDB')

        args = parser.parse_args()

        run_main(args)
    except Exception as ex:
        errprint(str(ex))
